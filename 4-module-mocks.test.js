/*
 * Manually mocking a built-in module. This loads the mock defined in `__mocks__/fs/promises.js`.
 * Alternatively, we could have provided a mock factory function as the second argument to create a
 * one-off mock for only this test file.
 *
 * If you don't specify a mock factory function, and no manual mock module exists, Jest will
 * automock the module:
 *
 * - function  -> mock function (as generated by `jest.fn()`)
 * - array     -> new empty array
 * - primitive -> value is unchanged
 * - object    -> deep clone of object, recursively mocking property values
 * - class     -> mock class with same shape, recursively mocking member functions and properties
 *
 * The `jest.mock()` call causes that module to be mocked whenever that module is `require()`d or
 * `import`ed within the scope of the tests declared in this file. Thus, when we `require()` the
 * `widget-factory` module, which in turn `require()`s the `fs/promises` module, it will use the
 * mock we declare here.
 *
 * If you've mocked a module but need the real one for some reason, you can get it with the
 * `jest.requireActual()` method.
 */
jest.mock('fs/promises');

const WidgetFactory = require('./widget-factory');
const fs = require('fs/promises'); // <-- mocked

let factory;

beforeEach(() => {
  factory = new WidgetFactory();
});

afterEach(() => {
  fs.mockClear();
});

test('Create widgets', async () => {
  const templateFile = 'template.json';
  const template = { type: 'A', size: 'large', color: 'green' };
  fs.mockFile(templateFile, template); // <-- this method only exists on the mock
  expect(factory.nextSerialNumber).toBe(0);
  await expect(factory.build(templateFile)).resolves.toEqual({
    ...template,
    serialNumber: 0,
  });
  await expect(factory.build()).resolves.toEqual({ serialNumber: 1 });
  expect(factory.nextSerialNumber).toBe(2);
});
